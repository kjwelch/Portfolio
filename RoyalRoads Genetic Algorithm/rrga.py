# -*- coding: utf-8 -*-
"""RRGA.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1BsmsxXeb8HMqF9xbGwzy3L-Lk-QNSEbX
"""

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import random
import math

def fitness(bitstring):
  return sum(bitstring)

def hiff(bitstring):
    if len(bitstring) == 1:
        return int(bitstring[0])  # Fitness is 1 if the single bit matches its position

    mid = len(bitstring) // 2
    left_substring = bitstring[:mid]
    right_substring = bitstring[mid:]

    # Recursively calculate fitness for left and right substrings
    left_fitness = hiff(left_substring)
    right_fitness = hiff(right_substring)

    # Combine fitness values according to the hierarchical structure
    if left_fitness == mid and right_fitness == mid:
        return mid + 1
    else:
        return left_fitness + right_fitness

def initPop(size, numBits, pop_size):
  # Create appropriately sized list with correct number of bits
  pop = []
  ret = [1] * numBits + [0] * (size-numBits)
  for i in range(pop_size):
    random.shuffle(ret)
    pop.append(ret)
  return pop

def hill_climber(bitstring, max_iterations=10000):
    current_solution = bitstring
    current_fitness = fitness(current_solution)
    progress = []

    for iteration in range(max_iterations):
        # Generate a random neighbor by flipping a random bit
        neighbor = current_solution.copy()
        random_flip = random.randint(0, len(bitstring) - 1)
        neighbor[random_flip] = 1 - neighbor[random_flip]
        neighbor_fitness = fitness(neighbor)

        # If the neighbor is better, move to it
        if neighbor_fitness > current_fitness:
            current_solution = neighbor
            current_fitness = neighbor_fitness

        # Track progress
        progress.append(current_fitness / len(current_solution))

    return current_solution, current_fitness, progress

def one_point_crossover(parent1, parent2):
    crossover_point = random.randint(0, bitstring_length - 1)
    child = parent1[:crossover_point] + parent2[crossover_point:]
    return child

def uniform_crossover(parent1, parent2):
    child = [parent1[i] if random.random() < 0.5 else parent2[i] for i in range(bitstring_length)]
    return child

def two_point_crossover(parent1, parent2):
    crossover_points = sorted(random.sample(range(bitstring_length), 2))
    child = parent1[:crossover_points[0]] + parent2[crossover_points[0]:crossover_points[1]] + parent1[crossover_points[1]:]
    return child

def mutate(bitstring, mutation_rate):
    mut_bitstring = bitstring[:]
    for i in range(len(bitstring)):
        if random.random() < mutation_rate:
            mut_bitstring[i] = 1 - mut_bitstring[i]
    return mut_bitstring

def genetic_algorithm(generations, population_size, mutation_rate, population, crossover, script,fit):
    max_fitness = max([fitness(individual) for individual in population])
    best_fitness_per_generation = []
    best_fitness_per_generation.append(max([fitness(individual) for individual in population]))
    for generation in range(generations):
        before_mean = str(int(sum([sum(bitstring) for bitstring in population]) / len(population)))
        # Evaluate the fitness of each individual in the population
        fitness_values = [fit(individual) for individual in population]

        # Select individuals for the next generation using roulette wheel selection
        selected_population = roulette_wheel_selection(population, fitness_values)

        # Create the next generation
        new_population = []
        for _ in range(population_size):
            parent1 = random.choice(selected_population)
            parent2 = random.choice(selected_population)
            child = crossover(parent1, parent2)

            # Mutate and Populate
            child = mutate(child, mutation_rate)
            new_population.append(child)

        population = new_population
        after_mean = str(int(sum([sum(bitstring) for bitstring in new_population]) / len(new_population)))
        if script == True:
          print('Before:'+before_mean+"\n"+'After:'+after_mean+'\n')
        if max_fitness <  max([fitness(individual) for individual in new_population]):
          max_fitness = max([fitness(individual) for individual in new_population])
        best_fitness_per_generation.append(max_fitness)

    worst_solution = min(population, key=fitness)
    worst_fitness = sum(worst_solution)
    best_solution = max(population, key=fitness)
    best_fitness = sum(best_solution)
    return best_solution, best_fitness, max_fitness, worst_solution, worst_fitness, after_mean, best_fitness_per_generation

def roulette_wheel_selection(population, fitness_values):
    total_fitness = sum(fitness_values)
    selected_pop = []
    for _ in range(len(population)):
        random_value = random.uniform(0, total_fitness)
        index = 0
        while random_value > 0:
            random_value -= fitness_values[index]
            index += 1
        selected_pop.append(population[index - 1])
    return selected_pop

# Experimentation Functions

def runExperiment(bitstring_length, population_size, numBits, mutation_rate, generations, crossover, fit):
  population = initPop(bitstring_length, numBits, population_size)
  best_solution, best_fitness, max_fitness, worst_solution, worst_fitness, mean, bfit = genetic_algorithm(generations, population_size, mutation_rate, population, crossover, False, fit)
  return best_solution, best_fitness, max_fitness, worst_solution, worst_fitness, mean, bfit

def ThirtyRuns(crossover, fit, generations, scriptable):
  bitstring_length = 64
  population_size = 128
  mutation_rate = 0.005
  numBits = 0

  df = pd.DataFrame(columns=['g'+str(i) for i in range(generations+1)]+['max','min','mean'])
  parameter_settings = ['bitstring_length','population_size','numBits','mutRate','Generations']
  csv_df = pd.DataFrame(columns=[parameter_settings])

  for i in range(31):
    best_solution, best_fitness, max_fitness, worst_solution, worst_fitness, mean, bfit = runExperiment(bitstring_length, population_size, numBits, mutation_rate, generations, crossover, fit)
    bfit = bfit + [max_fitness, worst_fitness, mean]
    df = pd.concat([pd.DataFrame([bfit], columns=df.columns), df], ignore_index=True)
    csv_df = pd.concat([pd.DataFrame([[bitstring_length, population_size, numBits, mutation_rate, generations]], columns=csv_df.columns),csv_df], ignore_index=True)
    if scriptable == True:
  # Print the best solution and its fitness
      print("Run #",i)
      print("Best Solution:", best_solution)
      print("Best Fitness:", best_fitness)
      print("MAX Fitness:", max_fitness,"\n")
      print("Worst Solution:", worst_solution)
      print("Worst Fitness:", worst_fitness)
      print("Mean:", mean,'\n\n')
  csv_df = csv_df.join(df)
  csv_df.to_csv('GAExperiments.csv')
  return df

####################
#### Experiment ####
####################

# This runs 30 independant runs of the genetic_algorithm experiment set up in the runExperiment function. 
# Output includes statistics for each run of the runExperiment function if striptable = True. 
# The graph output plots each experiment's max, min, and mean fitness. Because all runs are independent, 
# there is no progress made from run to run which can be seen with random variation in the progression of the line graph.

# 3 experiments are done in this manner with the only difference being the crossover function referenced above each experiment



# Single Point Crossover Experiment
generations = 100
df = ThirtyRuns(one_point_crossover, hiff, generations, True)
# Plot Line graph
plot_df = df.iloc[:, -3:]
plot_df.plot.line()

# Two Point Crossover Experiment

generations = 100
df = ThirtyRuns(two_point_crossover, hiff, generations, True)
# Plot Line graph
plot_df = df.iloc[:, -3:]
plot_df.plot.line()

# Uniform Crossover Experiment

generations = 100
df = ThirtyRuns(uniform_crossover, hiff, generations, True)
# Plot Line graph
plot_df = df.iloc[:, -3:]
plot_df.plot.line()
